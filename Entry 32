The Redux Toolkit simplifies the process of managing global state in a React application by providing streamlined tools like configureStore, createSlice, reducers, and dispatching actions. Here’s a breakdown of these core concepts and how they work together in a typical Redux workflow:
1. Create Store (configureStore)

    The store is a single JavaScript object that holds the entire state of your application.
    In Redux Toolkit, the configureStore function is used to create the Redux store. It simplifies store setup by automatically configuring good defaults, including middleware and DevTools setup.
    The store manages the state and handles all the state updates triggered by dispatched actions.

import { configureStore } from '@reduxjs/toolkit';
import userReducer from './userSlice';

const store = configureStore({
  reducer: {
    user: userReducer,
  },
});

export default store;

2. Reducers

    Reducers are pure functions that specify how the state should change in response to actions.
    Each reducer function takes two arguments: the current state and the action object.
    Reducers process actions and return a new state based on the action type and payload.

const userReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'user/login':
      return { ...state, isLoggedIn: true };
    case 'user/logout':
      return { ...state, isLoggedIn: false };
    default:
      return state;
  }
};

3. Slices (createSlice)

    createSlice is a helper function in Redux Toolkit that automatically generates action creators and action types based on the reducers you provide.
    Each slice manages a portion of the global state, typically grouped by feature or domain (e.g., user, cart, product).
    createSlice also simplifies reducer functions by allowing us to write code that appears to mutate the state, but behind the scenes, Redux Toolkit uses the immer library to handle immutability.
    A slice includes a name, initial state, reducers (state-updating logic), and optionally, extra reducers for external actions.

import { createSlice } from '@reduxjs/toolkit';

const userSlice = createSlice({
  name: 'user',
  initialState: {
    isLoggedIn: false,
  },
  reducers: {
    login: (state) => {
      state.isLoggedIn = true;
    },
    logout: (state) => {
      state.isLoggedIn = false;
    },
  },
});

export const { login, logout } = userSlice.actions;
export default userSlice.reducer;

    In this example, userSlice generates login and logout actions that can be dispatched to the store, and a reducer function to handle these actions.

4. Dispatch

    The dispatch function sends an action to the Redux store. Dispatching an action triggers all reducers to check if they need to update the state in response.
    With Redux Toolkit, you can dispatch the actions generated by slices directly.

import { useDispatch } from 'react-redux';
import { login, logout } from './userSlice';

const App = () => {
  const dispatch = useDispatch();

  const handleLogin = () => {
    dispatch(login());
  };

  const handleLogout = () => {
    dispatch(logout());
  };

  return (
    <div>
      <button onClick={handleLogin}>Login</button>
      <button onClick={handleLogout}>Logout</button>
    </div>
  );
};

How They Work Together

    Define the Slices: First, you create slices using createSlice for each part of your application state. Each slice handles its own piece of state and includes actions and reducers for updating it.

    Combine Reducers and Create the Store: You use configureStore to set up the Redux store with the reducers generated by each slice. The store holds the complete state of the app.

    Dispatch Actions: When the user interacts with the UI (e.g., clicking a login button), you dispatch an action like login(). This action describes the intention to update the state.

    Reducers Update State: The appropriate reducer (in this case, the userSlice reducer) listens for this action and updates its portion of the state in response. Redux Toolkit ensures immutability while updating state.

    React Components Receive Updated State: Components can access the updated state using selectors like useSelector, which lets them rerender based on the new state.

This workflow provides a clear separation of concerns, where actions trigger state updates, reducers determine how the state changes, and components react to state changes.

Ques: if the state is saved in the store, why does it resets when page reloads?

In Redux, the state is held in memory by the Redux store, which is lost when the page reloads because the browser's memory is cleared. Each time a page reloads, the JavaScript that runs on the page restarts, initializing the store with its default values (typically set by initialState in each slice).
Ways to Persist Redux State Across Page Reloads

To retain the Redux state after a page reload, you need to persist it somewhere outside the browser’s memory, like localStorage, sessionStorage, or a database. Here’s how to implement it with localStorage, which is commonly used for this purpose:

    Save State to localStorage on Change:
        Use a subscribe listener on the store to save the state to localStorage whenever it changes.

    Rehydrate State from localStorage:
        When the store initializes, check localStorage for any saved state and use that as the initial state.

Here’s how you can set it up in a Redux Toolkit setup:
1. Save State to localStorage

You can set up a subscribe function on the Redux store to listen for state changes and save them to localStorage:

import { configureStore } from '@reduxjs/toolkit';
import rootReducer from './reducers'; // Assume this imports your combined reducers

const store = configureStore({
  reducer: rootReducer,
});

// Function to save state to localStorage
function saveStateToLocalStorage(state) {
  try {
    const serializedState = JSON.stringify(state);
    localStorage.setItem('appState', serializedState);
  } catch (error) {
    console.error('Could not save state', error);
  }
}

// Listen for store changes and save to localStorage
store.subscribe(() => {
  saveStateToLocalStorage(store.getState());
});

2. Load State from localStorage

To load the saved state when the store initializes, read from localStorage before configuring the store:

function loadStateFromLocalStorage() {
  try {
    const serializedState = localStorage.getItem('appState');
    if (serializedState === null) return undefined;
    return JSON.parse(serializedState);
  } catch (error) {
    console.error('Could not load state', error);
    return undefined;
  }
}

const preloadedState = loadStateFromLocalStorage();

const store = configureStore({
  reducer: rootReducer,
  preloadedState,  // Set the initial state from localStorage if available
});

Complete Workflow

    Load the Saved State: When the app starts, it reads from localStorage and uses that state to initialize the Redux store.
    Subscribe to Changes: Any changes to the store are saved back to localStorage.
    Persisted State: Now, even after a page reload, the Redux store will initialize with the saved state from localStorage.

Using Middleware for Persistence

If you prefer a more structured approach, you could also use a Redux middleware like redux-persist. This library handles saving and loading the state for you, which can simplify your code and add more options for handling persisted state.
